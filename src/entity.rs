use std::hash::{Hash, Hasher};
use std::marker::PhantomData;
use std::num::NonZeroU32;

#[cfg(debug_assertions)]
use std::fmt::{Debug, Formatter, Result as FmtResult};

use crate::error::EcsError;
use crate::index::{TrimmedIndex, MAX_DATA_INDEX};
use crate::traits::{Archetype, EntityKey};
use crate::version::{ArchetypeVersion, SlotVersion};

// NOTE: While this is extremely unlikely to change, if it does, the proc
// macros need to be updated manually with the new type assumptions.
pub type ArchetypeId = u8;

// How many bits of a u32 entity index are reserved for the archetype ID.
pub(crate) const ARCHETYPE_ID_BITS: u32 = ArchetypeId::BITS;

/// A statically typed handle to an entity of a specific archetype.
///
/// On its own, this key does very little. Its primary purpose is to provide
/// indexed access to component data within an ECS world and its archetypes.
/// Entity handles are opaque and can't be accessed beyond type information.
///
/// As a data structure, an entity has two parts -- a slot index and a
/// generational version number. The slot index is used by the archetype data
/// structure to find the entity's component data, and the version number is
/// used to safely avoid attempts to access data for a stale `Entity` handle.
///
/// By default, when this version overflows (i.e., a single entity slot
/// was destroyed and reused for a new entity u32::MAX times), it will panic.
/// If instead you would like to allow entity slot versions to wrap, you can
/// enable the `wrapping_version` crate feature instead. Note that this could
/// allow invalid entity access, but doing so will not access invalid memory,
/// and the chances of this happening are infinitesimally small.
pub struct Entity<A: Archetype> {
    inner: EntityAny,
    _type: PhantomData<fn() -> A>,
}

/// A statically typed, versioned direct entity index for accelerated lookup.
///
/// Unlike [`Entity`], this key points directly to the component index in
/// the archetype, rather than the version-checked slot. This skips one level
/// of indirection on lookup, but is sensitive to archetype order changes (e.g.
/// when removing an entity). Because of this, this handle keeps a version
/// number on the archetype itself, rather than the entity's slot. Attempting
/// to use a direct entity handle on an archetype that has added or removed an
/// entity since the handle was created will fail access due to invalidation,
/// even if the index may still be correct.
///
/// By default, when this version overflows (i.e., an archetype has added or
/// removed an entity `u32::MAX` times), it will cause a panic. If instead
/// you would like to allow archetype versions to wrap, you can enable the
/// `wrapping_version` crate feature instead. Note that this could allow
/// invalid entity access, but doing so will not access invalid memory, and
/// the chances of this happening are infinitesimally small.
pub struct EntityDirect<A: Archetype> {
    inner: EntityDirectAny,
    _type: PhantomData<fn() -> A>,
}

/// A dynamically typed handle to an entity of some runtime archetype.
///
/// This behaves like an [`Entity`] key, but its type is only known at runtime.
/// To determine its type, use `archetype_id()`, or use the `resolve()` method
/// generated by the `ecs_world!` declaration to convert the `EntityAny` into
/// an enum with each possible archetype outcome.
#[derive(Clone, Copy, Eq, PartialEq)]
pub struct EntityAny {
    key: u32, // [ slot_index (u24) | archetype_id (u8) ]
    version: SlotVersion,
}

/// A dynamically typed, versioned direct entity index of some runtime archetype.
///
/// This behaves like an [`EntityDirect`] key, but its type is only known at runtime.
/// To determine its type, use `archetype_id()`, or use the `resolve()` method
/// generated by the `ecs_world!` declaration to convert the `EntityDirectAny` into
/// an enum with each possible archetype outcome.
#[derive(Clone, Copy, Eq, PartialEq)]
pub struct EntityDirectAny {
    key: u32, // [ dense_index (u24) | archetype_id (u8) ]
    version: ArchetypeVersion,
}

impl<A: Archetype> Entity<A> {
    #[inline(always)]
    pub(crate) fn new(
        slot_index: TrimmedIndex, //.
        version: SlotVersion,
    ) -> Self {
        Self {
            inner: EntityAny::new(slot_index, A::ARCHETYPE_ID, version),
            _type: PhantomData,
        }
    }

    #[inline(always)]
    pub(crate) fn slot_index(&self) -> TrimmedIndex {
        self.inner.slot_index()
    }

    #[inline(always)]
    pub(crate) fn version(&self) -> SlotVersion {
        self.inner.version()
    }

    /// Creates a new typed `Entity` from an `EntityAny`.
    ///
    /// In match statements, this tends to optimize better than `TryFrom`.
    ///
    /// # Panics
    ///
    /// Panics if the given `EntityAny` is not an entity of this type.
    #[inline(always)]
    pub fn from_any(entity: EntityAny) -> Self {
        if entity.archetype_id() != A::ARCHETYPE_ID {
            panic!("invalid entity conversion");
        }

        Self {
            inner: entity,
            _type: PhantomData,
        }
    }

    /// Creates new a typed `Entity` from an `EntityAny` without checking its archetype.
    ///
    /// While this is not an unsafe operation in the Rust sense (all bounds checks are still
    /// enforced), this should generally be avoided when possible. The intended use of this
    /// function is to skip redundant checks when using direct archetype IDs in a `match`
    /// statement. Improper use may result in logic errors from incorrect data access.
    #[inline(always)]
    pub fn from_any_unchecked(entity: EntityAny) -> Self {
        debug_assert!(entity.archetype_id() == A::ARCHETYPE_ID);

        Self {
            inner: entity,
            _type: PhantomData,
        }
    }

    /// Converts this `Entity<A>` directly into an `EntityAny`.
    ///
    /// Useful for situations where type inference can't deduce a conversion.
    #[inline(always)]
    pub fn into_any(self) -> EntityAny {
        self.inner
    }

    /// Returns this entity's stored `ARCHETYPE_ID` value.
    ///
    /// This is the same `ARCHETYPE_ID` as the archetype this entity belongs to.
    #[inline(always)]
    pub const fn archetype_id(self) -> ArchetypeId {
        A::ARCHETYPE_ID
    }
}

impl EntityAny {
    #[inline(always)]
    pub(crate) fn new(
        slot_index: TrimmedIndex, //.
        archetype_id: ArchetypeId,
        version: SlotVersion,
    ) -> Self {
        let archetype_id: u32 = archetype_id.into();
        let slot_index: u32 = slot_index.into();
        let key = (slot_index << ARCHETYPE_ID_BITS) | archetype_id;
        Self { key, version }
    }

    /// Creates a new entity handle from raw inner data. Useful for applications like FFI.
    ///
    /// # Safety
    ///
    /// Despite the use of raw unchecked values, this is still an inherently memory-safe
    /// operation and produces a memory-safe handle. Entity access in gecs is validated
    /// to prevent issues from bad raw entity creation and other bugs like using an entity
    /// handle from a different ECS world. While altering the values in a key might cause
    /// access to unexpected data, it won't cause access to uninitialized memory, invalid
    /// entities, or result in other undefined behavior.
    #[inline(always)]
    pub fn from_raw(raw: (u32, u32)) -> Result<Self, EcsError> {
        let (key, version) = raw;
        // This really only checks that the version is nonzero. All other key/versions are "valid".
        let version = SlotVersion::new(NonZeroU32::new(version).ok_or(EcsError::InvalidRawEntity)?);
        Ok(Self { key, version })
    }

    /// Returns the raw inner data of this entity handle. Useful for applications like FFI.
    ///
    /// The data returned has no inherent value and should not be modified or reordered.
    /// The only use for this data is for creating a handle using [`EntityAny::from_raw`].
    #[inline(always)]
    pub fn raw(&self) -> (u32, u32) {
        (self.key, self.version.get().get())
    }

    #[inline(always)]
    pub(crate) fn slot_index(&self) -> TrimmedIndex {
        unsafe {
            // SAFETY: We know the remaining data can fit in a DataIndex
            debug_assert!(self.key >> ARCHETYPE_ID_BITS <= MAX_DATA_INDEX);
            TrimmedIndex::new_u32(self.key >> ARCHETYPE_ID_BITS).unwrap_unchecked()
        }
    }

    /// Returns this entity's stored `ARCHETYPE_ID` value.
    ///
    /// This is the same `ARCHETYPE_ID` as the archetype this entity belongs to.
    #[inline(always)]
    pub const fn archetype_id(self) -> ArchetypeId {
        self.key as ArchetypeId // Trim off the bottom to get the ID
    }

    #[inline(always)]
    pub(crate) const fn version(&self) -> SlotVersion {
        self.version
    }

    /// Returns self.
    #[inline(always)]
    pub fn into_any(self) -> EntityAny {
        self
    }
}

impl<A: Archetype> EntityDirect<A> {
    #[inline(always)]
    pub(crate) fn new(
        dense_index: TrimmedIndex, //.
        version: ArchetypeVersion,
    ) -> Self {
        Self {
            inner: EntityDirectAny::new(dense_index, A::ARCHETYPE_ID, version),
            _type: PhantomData,
        }
    }

    #[inline(always)]
    pub(crate) fn dense_index(&self) -> TrimmedIndex {
        self.inner.dense_index()
    }

    #[inline(always)]
    pub(crate) fn version(&self) -> ArchetypeVersion {
        self.inner.version()
    }

    /// Creates a new typed `EntityDirect` from an `EntityDirectAny`.
    ///
    /// In match statements, this tends to optimize better than `TryFrom`.
    ///
    /// # Panics
    ///
    /// Panics if the given `EntityDirectAny` is not an entity of this type.
    #[inline(always)]
    pub fn from_any(entity: EntityDirectAny) -> Self {
        if entity.archetype_id() != A::ARCHETYPE_ID {
            panic!("invalid entity conversion");
        }

        Self {
            inner: entity,
            _type: PhantomData,
        }
    }

    /// Creates new a typed `EntityDirect` from an `EntityDirectAny` without checking its archetype.
    ///
    /// While this is not an unsafe operation in the Rust sense (all bounds checks are still
    /// enforced), this should generally be avoided when possible. The intended use of this
    /// function is to skip redundant checks when using stored archetype IDs in a `match`
    /// statement. Improper use may result in logic errors from incorrect data access.
    #[inline(always)]
    pub fn from_any_unchecked(entity: EntityDirectAny) -> Self {
        debug_assert!(entity.archetype_id() == A::ARCHETYPE_ID);

        Self {
            inner: entity,
            _type: PhantomData,
        }
    }

    /// Converts this `EntityDirect<A>` directly into an `EntityDirectAny`.
    ///
    /// Useful for situations where type inference can't deduce a conversion.
    #[inline(always)]
    pub fn into_any(self) -> EntityDirectAny {
        self.inner
    }

    /// Returns this entity's stored `ARCHETYPE_ID` value.
    ///
    /// This is the same `ARCHETYPE_ID` as the archetype this entity belongs to.
    #[inline(always)]
    pub const fn archetype_id(self) -> ArchetypeId {
        A::ARCHETYPE_ID
    }
}

impl EntityDirectAny {
    #[inline(always)]
    pub(crate) fn new(
        dense_index: TrimmedIndex, //.
        archetype_id: ArchetypeId,
        version: ArchetypeVersion,
    ) -> Self {
        let archetype_id: u32 = archetype_id.into();
        let dense_index: u32 = dense_index.into();
        let key = (dense_index << ARCHETYPE_ID_BITS) | archetype_id;
        Self { key, version }
    }

    #[inline(always)]
    pub(crate) fn dense_index(&self) -> TrimmedIndex {
        unsafe {
            // SAFETY: We know the remaining data can fit in a DataIndex
            debug_assert!(self.key >> ARCHETYPE_ID_BITS <= MAX_DATA_INDEX);
            TrimmedIndex::new_u32(self.key >> ARCHETYPE_ID_BITS).unwrap_unchecked()
        }
    }

    /// Returns this entity's stored `ARCHETYPE_ID` value.
    ///
    /// This is the same `ARCHETYPE_ID` as the archetype this entity belongs to.
    #[inline(always)]
    pub const fn archetype_id(self) -> ArchetypeId {
        self.key as ArchetypeId // Trim off the bottom to get the ID
    }

    #[inline(always)]
    pub(crate) const fn version(&self) -> ArchetypeVersion {
        self.version
    }

    /// Returns self.
    #[inline(always)]
    pub fn into_any(self) -> EntityDirectAny {
        self
    }
}

impl Hash for EntityAny {
    #[inline(always)]
    fn hash<H: Hasher>(&self, state: &mut H) {
        // Hash as a single u64 rather than two u32s.
        let index: u64 = self.key.into();
        let version: u64 = self.version.get().get().into();
        let combined = (index << 32) | version;
        combined.hash(state);
    }
}

impl Hash for EntityDirectAny {
    #[inline(always)]
    fn hash<H: Hasher>(&self, state: &mut H) {
        // Hash as a single u64 rather than two u32s.
        let index: u64 = self.key.into();
        let version: u64 = self.version.get().get().into();
        let combined = (index << 32) | version;
        combined.hash(state);
    }
}

impl<A: Archetype> From<Entity<A>> for EntityAny {
    #[inline(always)]
    fn from(entity: Entity<A>) -> Self {
        entity.inner
    }
}

impl<A: Archetype> From<EntityDirect<A>> for EntityDirectAny {
    #[inline(always)]
    fn from(entity: EntityDirect<A>) -> Self {
        entity.inner
    }
}

impl<A: Archetype> TryFrom<EntityAny> for Entity<A> {
    type Error = EcsError;

    #[inline(always)]
    fn try_from(entity: EntityAny) -> Result<Self, Self::Error> {
        if entity.archetype_id() == A::ARCHETYPE_ID {
            Ok(Self {
                inner: entity,
                _type: PhantomData,
            })
        } else {
            Err(EcsError::InvalidEntityType)
        }
    }
}

impl<A: Archetype> TryFrom<EntityDirectAny> for EntityDirect<A> {
    type Error = EcsError;

    #[inline(always)]
    fn try_from(entity: EntityDirectAny) -> Result<Self, Self::Error> {
        if entity.archetype_id() == A::ARCHETYPE_ID {
            Ok(Self {
                inner: entity,
                _type: PhantomData,
            })
        } else {
            Err(EcsError::InvalidEntityType)
        }
    }
}

// Derive boilerplate until https://github.com/rust-lang/rust/issues/26925 is resolved

impl<A: Archetype> Clone for Entity<A> {
    #[inline(always)]
    fn clone(&self) -> Entity<A> {
        *self
    }
}

impl<A: Archetype> Clone for EntityDirect<A> {
    #[inline(always)]
    fn clone(&self) -> EntityDirect<A> {
        *self
    }
}

impl<A: Archetype> PartialEq for Entity<A> {
    fn eq(&self, other: &Self) -> bool {
        self.inner == other.inner
    }
}

impl<A: Archetype> PartialEq for EntityDirect<A> {
    fn eq(&self, other: &Self) -> bool {
        self.inner == other.inner
    }
}

impl<A: Archetype> Hash for Entity<A> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.inner.hash(state)
    }
}

impl<A: Archetype> Hash for EntityDirect<A> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.inner.hash(state)
    }
}

impl<A: Archetype> Copy for Entity<A> {}
impl<A: Archetype> Copy for EntityDirect<A> {}

impl<A: Archetype> Eq for Entity<A> {}
impl<A: Archetype> Eq for EntityDirect<A> {}

impl<A: Archetype> EntityKey for Entity<A> {
    type DestroyOutput = Option<A::Components>;
    type DirectOutput = EntityDirect<A>;
}

impl<A: Archetype> EntityKey for EntityDirect<A> {
    type DestroyOutput = Option<A::Components>;
    type DirectOutput = EntityDirect<A>;
}

impl EntityKey for EntityAny {
    type DestroyOutput = Option<()>;
    type DirectOutput = EntityDirectAny;
}

impl EntityKey for EntityDirectAny {
    type DestroyOutput = Option<()>;
    type DirectOutput = EntityDirectAny;
}

#[cfg(debug_assertions)]
impl<A: Archetype> Debug for Entity<A> {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(
            f,
            "Entity<_> {{ archetype_id: {}, slot_index: {}, version: {} }}",
            self.archetype_id(),
            u32::from(self.slot_index()),
            self.version().get(),
        )
    }
}

#[cfg(debug_assertions)]
impl<A: Archetype> Debug for EntityDirect<A> {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(
            f,
            "EntityDirect<_> {{ archetype_id: {}, dense_index: {}, version: {} }}",
            self.archetype_id(),
            u32::from(self.dense_index()),
            self.version().get(),
        )
    }
}

#[cfg(debug_assertions)]
impl Debug for EntityAny {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(
            f,
            "EntityAny {{ archetype_id: {}, slot_index: {}, version: {} }}",
            self.archetype_id(),
            u32::from(self.slot_index()),
            self.version().get(),
        )
    }
}

#[cfg(debug_assertions)]
impl Debug for EntityDirectAny {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(
            f,
            "EntityDirectAny {{ archetype_id: {}, dense_index: {}, version: {} }}",
            self.archetype_id(),
            u32::from(self.dense_index()),
            self.version().get(),
        )
    }
}

#[doc(hidden)]
pub mod __internal {
    use super::*;

    #[doc(hidden)]
    #[inline(always)]
    pub fn new_entity_direct<A: Archetype>(
        index: usize,
        version: ArchetypeVersion,
    ) -> EntityDirect<A> {
        EntityDirect::new(TrimmedIndex::new_usize(index).unwrap(), version)
    }
}
